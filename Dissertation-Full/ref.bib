@article{doi:10.1080/09720529.2021.1951435,
  author    = {Sudhakar Kumar and Sunil Kr. Singh and Naveen Aggarwal and Kriti Aggarwal},
  title     = {Evaluation of automatic parallelization algorithms to minimize speculative parallelism overheads: An experiment},
  journal   = {Journal of Discrete Mathematical Sciences and Cryptography},
  volume    = {24},
  number    = {5},
  pages     = {1517-1528},
  year      = {2021},
  publisher = {Taylor & Francis},
  doi       = {10.1080/09720529.2021.1951435},
  url       = {https://doi.org/10.1080/09720529.2021.1951435},
  eprint    = {https://doi.org/10.1080/09720529.2021.1951435}
}

@article{article,
  author  = {Sigman, Mariano and Dehaene, Stanislas},
  year    = {2008},
  month   = {07},
  pages   = {7585-98},
  title   = {Brain Mechanisms of Serial and Parallel Processing during Dual-Task Performance},
  volume  = {28},
  journal = {The Journal of neuroscience : the official journal of the Society for Neuroscience},
  doi     = {10.1523/JNEUROSCI.0948-08.2008}
}

@article{10.1145/361002.361016,
  author     = {Wegbreit, Ben},
  title      = {Mechanical Program Analysis},
  year       = {1975},
  issue_date = {Sept. 1975},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {18},
  number     = {9},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/361002.361016},
  doi        = {10.1145/361002.361016},
  abstract   = {One means of analyzing program performance is by deriving closed-form expressions for their execution behavior. This paper discusses the mechanization of such analysis, and describes a system, Metric, which is able to analyze simple Lisp programs and produce, for example, closed-form expressions for their running time expressed in terms of size of input. This paper presents the reasons for mechanizing program analysis, describes the operation of Metric, explains its implementation, and discusses its limitations.},
  journal    = {Commun. ACM},
  month      = {09},
  pages      = {528--539},
  numpages   = {12},
  keywords   = {analysis of algorithms, programming languages, analysis of programs, execution behavior, difference equations, list processing, execution time, Lisp, performance analysis, generating functions, algebraic manipulation}
}

@article{Sigman7585,
  author    = {Sigman, Mariano and Dehaene, Stanislas},
  title     = {Brain Mechanisms of Serial and Parallel Processing during Dual-Task Performance},
  volume    = {28},
  number    = {30},
  pages     = {7585--7598},
  year      = {2008},
  doi       = {10.1523/JNEUROSCI.0948-08.2008},
  publisher = {Society for Neuroscience},
  abstract  = {The psychological refractory period (PRP) refers to the fact that humans typically cannot perform two tasks at once. Behavioral experiments have led to the proposal that, in fact, peripheral perceptual and motor stages continue to operate in parallel, and that only a central decision stage imposes a serial bottleneck. We tested this model using neuroimaging methods combined with innovative time-sensitive analysis tools. Subjects performed a dual-task visual{\textendash}auditory paradigm in which a delay of 300 ms was injected into the auditory task either within or outside of the dual-task interference period. Event-related potentials indicated that the first \~{}250 ms of processing were insensitive to dual-task interference, and that the PRP was mainly reflected in a delayed global component. By a clustering analysis based on time-resolved functional magnetic resonance imaging, we identified networks with qualitatively different timing properties: sensory areas tracked the objective time of stimulus presentation, a bilateral parietoprefrontal network correlated with the PRP delay, and an extended bilateral network that included bilateral posterior parietal cortex, premotor cortex, supplementary motor area, anterior part of the insula, and cerebellum was shared by both tasks during the extent of dual-task performance. The results provide physiological evidence for the coexistence of serial and parallel processes within a cognitive task.},
  issn      = {0270-6474},
  url       = {https://www.jneurosci.org/content/28/30/7585},
  eprint    = {https://www.jneurosci.org/content/28/30/7585.full.pdf},
  journal   = {Journal of Neuroscience}
}

@article{10.1145/361002.361016,
  author     = {Wegbreit, Ben},
  title      = {Mechanical Program Analysis},
  year       = {1975},
  issue_date = {Sept. 1975},
  publisher  = {Association for Computing Machinery},
  address    = {New York, NY, USA},
  volume     = {18},
  number     = {9},
  issn       = {0001-0782},
  url        = {https://doi.org/10.1145/361002.361016},
  doi        = {10.1145/361002.361016},
  abstract   = {One means of analyzing program performance is by deriving closed-form expressions for their execution behavior. This paper discusses the mechanization of such analysis, and describes a system, Metric, which is able to analyze simple Lisp programs and produce, for example, closed-form expressions for their running time expressed in terms of size of input. This paper presents the reasons for mechanizing program analysis, describes the operation of Metric, explains its implementation, and discusses its limitations.},
  journal    = {Commun. ACM},
  month      = {sep},
  pages      = {528--539},
  numpages   = {12},
  keywords   = {analysis of algorithms, programming languages, analysis of programs, execution behavior, difference equations, list processing, execution time, Lisp, performance analysis, generating functions, algebraic manipulation}
}

@online{Optimising-Compilers-Lecture-13-Effect-Systems,
  author  = {Timothy M. Jones},
  title   = {Optimising Compilers Lecture 13 Effect Systems},
  year    = {2022},
  url     = {https://www.cl.cam.ac.uk/teaching/2122/OptComp/slides/lecture13.pdf},
  urldate = {2022-10-07}
}

@inproceedings{10.1145/73560.73564,
  author    = {Lucassen, J. M. and Gifford, D. K.},
  title     = {Polymorphic Effect Systems},
  year      = {1988},
  isbn      = {0897912527},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/73560.73564},
  doi       = {10.1145/73560.73564},
  abstract  = {We present a new approach to programming languages for parallel computers that uses an effect system to discover expression scheduling constraints. This effect system is part of a 'kinded' type system with three base kinds: types, which describe the value that an expression may return; effects, which describe the side-effects that an expression may have; and regions, which describe the area of the store in which side-effects may occur. Types, effects and regions are collectively called descriptions.Expressions can be abstracted over any kind of description variable -- this permits type, effect and region polymorphism. Unobservable side-effects can be masked by the effect system; an effect soundness property guarantees that the effects computed statically by the effect system are a conservative approximation of the actual side-effects that a given expression may have.The effect system we describe performs certain kinds of side-effect analysis that were not previously feasible. Experimental data from the programming language FX indicate that an effect system can be used effectively to compile programs for parallel computers.},
  booktitle = {Proceedings of the 15th ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {47–57},
  numpages  = {11},
  location  = {San Diego, California, USA},
  series    = {POPL '88}
}

@inproceedings{10.1145/1478462.1478537,
  author    = {Beizer, Boris},
  title     = {Analytical Techniques for the Statistical Evaluation of Program Running Time},
  year      = {1970},
  isbn      = {9781450379045},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/1478462.1478537},
  doi       = {10.1145/1478462.1478537},
  abstract  = {The design of large software systems or real-time systems imposes several constraints on the designer. Predominant among these are the running time of the programs, the amount of memory used by these programs, and the input/output channel utilization. A well considered design not only runs, but has optimum efficiency. Efficiency is often measured by the running time of the program.},
  booktitle = {Proceedings of the November 17-19, 1970, Fall Joint Computer Conference},
  pages     = {519–524},
  numpages  = {6},
  location  = {Houston, Texas},
  series    = {AFIPS '70 (Fall)}
}

@inproceedings{10.1007/978-3-540-30579-8_14,
  author    = {Salcianu, Alexandru
               and Rinard, Martin},
  editor    = {Cousot, Radhia},
  title     = {Purity and Side Effect Analysis for Java Programs},
  booktitle = {Verification, Model Checking, and Abstract Interpretation},
  year      = {2005},
  publisher = {Springer Berlin Heidelberg},
  address   = {Berlin, Heidelberg},
  pages     = {199--215},
  abstract  = {We present a new purity and side effect analysis for Java programs. A method is pure if it does not mutate any location that exists in the program state right before the invocation of the method. Our analysis is built on top of a combined pointer and escape analysis, and is able to determine that methods are pure even when the methods mutate the heap, provided they mutate only new objects.},
  isbn      = {978-3-540-30579-8}
}

@article{talpin_jouvelot_1992,
  title     = {Polymorphic type, region and effect inference},
  volume    = {2},
  doi       = {10.1017/S0956796800000393},
  number    = {3},
  journal   = {Journal of Functional Programming},
  publisher = {Cambridge University Press},
  author    = {Talpin, Jean-Pierre and Jouvelot, Pierre},
  year      = {1992},
  pages     = {245–271}
}

@article{article,
  author = {Jouvelot, Pierre and Gifford, David},
  year   = {2001},
  month  = {06},
  pages  = {},
  title  = {Algebraic Reconstruction of Types and Effects},
  doi    = {10.1145/99583.99623}
}

@inproceedings{Huelsbergen1994UsingTR,
  title     = {Using the run-time sizes of data structures to guide parallel-thread creation},
  author    = {Lorenz Huelsbergen and James R. Larus and Alexander Aiken},
  booktitle = {LFP '94},
  year      = {1994}
}

@inproceedings{DBLP:conf/lfp/ReistadG94,
  author    = {Brian Reistad and
               David K. Gifford},
  editor    = {Robert R. Kessler},
  title     = {Static Dependent Costs for Estimating Execution Time},
  booktitle = {Proceedings of the 1994 {ACM} Conference on {LISP} and Functional
               Programming, Orlando, Florida, USA, 27-29 June 1994},
  pages     = {65--78},
  publisher = {{ACM}},
  year      = {1994},
  url       = {https://doi.org/10.1145/182409.182439},
  doi       = {10.1145/182409.182439},
  timestamp = {Fri, 06 Aug 2021 15:08:55 +0200},
  biburl    = {https://dblp.org/rec/conf/lfp/ReistadG94.bib},
  bibsource = {dblp computer science bibliography, https://dblp.org}
}

@misc{menhir,
  title     = {Menhir reference manual},
  url       = {https://gallium.inria.fr/~fpottier/menhir/manual.pdf},
  author    = {François Pottier and Yann Régis-Gianas},
  date      = {2016},
  urldate   = {2023-05-11},
  publisher = {Inria}
}

@misc{ocamllex,
  title   = {Lexer and parser generators (ocamllex, ocamlyacc)},
  url     = {https://v2.ocaml.org/manual/lexyacc.html},
  urldate = {2023-05-11}
}

@misc{ocaml,
  title   = {OCaml programming guidelines · ocaml tutorials},
  url     = {https://ocaml.org/docs/guidelines},
  urldate = {2023-05-06}
} 

@misc{ocamlformat,
  title   = {ocamlformat},
  url     = {https://github.com/ocaml-ppx/ocamlformat},
  urldate = {2023-05-06}
} 

@misc{dune,
  title   = {dune},
  url     = {https://github.com/ocaml/dune},
  urldate = {2023-05-06}
} 

@article{reps2000undecidability,
  title     = {Undecidability of context-sensitive data-dependence analysis},
  author    = {Reps, Thomas},
  journal   = {ACM Transactions on Programming Languages and Systems (TOPLAS)},
  volume    = {22},
  number    = {1},
  pages     = {162--186},
  year      = {2000},
  publisher = {ACM New York, NY, USA}
}

@inproceedings{10.1145/237721.237727,
  author    = {Steensgaard, Bjarne},
  title     = {Points-to Analysis in Almost Linear Time},
  year      = {1996},
  isbn      = {0897917693},
  publisher = {Association for Computing Machinery},
  address   = {New York, NY, USA},
  url       = {https://doi.org/10.1145/237721.237727},
  doi       = {10.1145/237721.237727},
  abstract  = {We present an interprocedural flow-insensitive points-to analysis based on type inference methods with an almost linear time cost complexity To our knowledge, this is the asymptotically fastest non-trivial interprocedural points-to analysis algorithm yet described The algorithm is based on a non-standard type system. The type inferred for any variable represents a set of locations and includes a type which in turn represents a set of locations possibly pointed to by the variable. The type inferred for a function variable represents a set of functions It may point to and includes a type signature for these functions The results are equivalent to those of a flow-insensitive alias analysis (and control flow analysis) that assumes alias relations are reflexive and transitive.This work makes three contributions. The first is a type system for describing a universally valid storage shape graph for a program in linear space. The second is a constraint system which often leads to better results than the "obvious" constraint system for the given type system The third is an almost linear time algorithm for points-to analysis by solving a constraint system.},
  booktitle = {Proceedings of the 23rd ACM SIGPLAN-SIGACT Symposium on Principles of Programming Languages},
  pages     = {32–41},
  numpages  = {10},
  location  = {St. Petersburg Beach, Florida, USA},
  series    = {POPL '96}
}

@phdthesis{andersen1994program,
  title  = {Program analysis and specialization for the C programming language},
  author = {Andersen, Lars Ole},
  year   = {1994},
  school = {Citeseer}
}

@article{harrison1977compiler,
  title     = {Compiler analysis of the value ranges for variables},
  author    = {Harrison, William H.},
  journal   = {IEEE Transactions on software engineering},
  number    = {3},
  pages     = {243--250},
  year      = {1977},
  publisher = {IEEE}
}
